"""
Features implementation within MEDEAS.
Wrote by Noe Diffels
October 2024

This file defines the 6 features and the peak load (needed in some features definitions) required by the surrogate model.
"""

import pandas as pd
import os
file_directory = os.path.dirname(os.path.abspath(__file__))

# Import the dataframe
df_rNTC = pd.read_csv(file_directory + r"\modules_pymedeas_eu\surr_model\pypsa\rNTC\interp_rNTC.csv", index_col='Year')
df_ratios_rNTC_TW = pd.read_csv(file_directory+r"\modules_pymedeas_eu\surr_model\pypsa\rNTC\ratio_rNTC_TW.csv", index_col='Year') 

@component.add(
    name="Peak Demand (ie Peak Load)",
    units="TW",
    comp_type="Auxiliary",
    comp_subtype="Normal",
    depends_on={"total_fe_elec_demand_twh": 1},
)
def peak_load():
        """
        Peak Electrical Load defined using the total FE Elec demand in TWh. 
        Use the Equation 4.3 from Romain Cloux's thesis, making the peak demand around x1.3 the mean load, ~0.4 TW.
        """
        return total_fe_elec_demand_twh()/(365*24)/0.736 # From Eq. (4.3) in Romain Cloux's thesis.

@component.add(
    name="Capacity Ratio",
    units="Dmnl",
    comp_type="Auxiliary",
    comp_subtype="Normal",
    depends_on={"fe_elec_generation_from_fossil_fuels": 3,
                "fe_nuclear_elec_generation_twh": 1, 
                "installed_capacity_res_elec": 5,
                "cp_nuclear": 1
                },
)
def cap_ratio():
    """
    The capacity ratio represents the ratio between the nominal power that could be produced by all units of the power system (flexible and slow units) and the peak load.
    """
    # NRE
    # Capacity Factors estimations are derived from https://www.eia.gov/todayinenergy/detail.php?id=22832.
    # Refers to section 3.3.3 - Capacity Ratio for further information.
    cap_installed_oil = fe_elec_generation_from_fossil_fuels().loc['liquids']/(0.19 * 365*24) # TW
    cap_installed_gas = fe_elec_generation_from_fossil_fuels().loc['gases']/(0.39 * 365*24) # TW
    cap_installed_coal = fe_elec_generation_from_fossil_fuels().loc['solids']/(0.51 * 365*24) # TW
    cap_installed_nuc = fe_nuclear_elec_generation_twh()/(float(cp_nuclear()) * 365*24) # TW


    # Previous Capacity Factors: https://en.wikipedia.org/wiki/Capacity_factor
    # oil = 0.1, gas = 0.3, coal = 0.6, nuc = 0.9

    # RES
    cap_installed_geoth = installed_capacity_res_elec().loc['geot_elec'] # TW
    cap_installed_biomass = installed_capacity_res_elec().loc['solid_bioE_elec'] # TW
    cap_installed_hydro = installed_capacity_res_elec().loc['hydro'] # TW
    cap_installed_oceanic = installed_capacity_res_elec().loc['oceanic'] # TW
    cap_installed_csp = installed_capacity_res_elec().loc['CSP'] # TW

    cap_installed_tot = cap_installed_oil + cap_installed_gas + cap_installed_coal + cap_installed_nuc + cap_installed_geoth + cap_installed_biomass # TW
    cap_installed_tot += cap_installed_hydro + cap_installed_oceanic + cap_installed_csp

    cap_ratio = float(cap_installed_tot/peak_load())

    bounds = (0.4, 1.3)
    if cap_ratio < bounds[0]:
          print(f"\nLower bound for capacity ratio reached. ({cap_ratio})")
          return bounds[0]
    elif cap_ratio > bounds[1]:
          print(f"\nUpper bound for capacity ratio reached. ({cap_ratio})")
          return bounds[1]
    else:
        return cap_ratio

@component.add(
    name="Share Flex",
    units="Dmnl",
    comp_type="Auxiliary",
    comp_subtype="Normal",
    depends_on={"time": 1},
)
def share_flex():
    """
    The share flex represents the power capacity share generated by flexible power plants among all units (flexible and slow).
    It is computed using data from Romain Cloux's thesis: Table 3.1 (P15), Reference value for October 2019, share_flex = 0.41 [-].
    And assumption of lower bound at the first time step: share_flex = 0.251 [-] in 1995. (LB = 0.25) 
    
    """

    # Calculate the slope:
    slope = (0.41-0.251)/(2019-1995)
    # The y-axis value p at origin, is computed with 2019 value:
    p = 0.41 - slope * (2019 - 1995)
    share_flex = float(slope * (time() - 1995) + p)
    bounds = (0.25, 0.9)
    if share_flex < bounds[0]:
          print(f"\nLower bound for share_flex reached. ({share_flex})")
          return bounds[0]
    elif share_flex > bounds[1]:
          print(f"\nUpper bound for share_flex reached. ({share_flex})")
          return bounds[1]
    else:
        return share_flex


@component.add(
    name="Share Storage",
    units="Dmnl",
    comp_type="Auxiliary",
    comp_subtype="Normal",
    depends_on={"total_capacity_elec_storage_tw": 1, 
                "peak_load": 1},
)
def share_sto():
    """
    The share storage represents the share between the overall nominal storage power and the peak load.
    """

    share_sto = float(total_capacity_elec_storage_tw())/peak_load()
    bounds = (0, 3)
    if share_sto < bounds[0]:
        print(f"\nLower bound for share_sto reached. ({share_sto})")
        return bounds[0]
    elif share_sto > bounds[1]:
        print(f"\nUpper bound for share_sto reached. ({share_sto})")
        return bounds[1]
    else:
        return share_sto


@component.add(
    name="Share Wind",
    units="Dmnl",
    comp_type="Auxiliary",
    comp_subtype="Normal",
    depends_on={"installed_capacity_res_elec": 2, 
                "cp_res_elec": 2, 
                "peak_load": 2},
)
def share_wind():
    """
    The share wind represents the ratio of electricity generated by wind turbines (onshore + offshore) over the peak load.
    """

    share_wind_ON = float(installed_capacity_res_elec().loc['wind_onshore']*cp_res_elec().loc['wind_onshore'])/peak_load()/0.736
    share_wind_OFF = float(installed_capacity_res_elec().loc['wind_offshore']*cp_res_elec().loc['wind_offshore'])/peak_load()/0.736
    
    share_wind = share_wind_ON+share_wind_OFF
    bounds = (0, 0.55)
    if share_wind < bounds[0]:
        print(f"\nLower bound for share_wind reached. ({share_wind})")
        return bounds[0]
    elif share_wind > bounds[1]:
        print(f"\nUpper bound for share_wind reached. ({share_wind})")
        return bounds[1]
    else:
        return share_wind
    

@component.add(
    name="Share PV",
    units="Dmnl",
    comp_type="Auxiliary",
    comp_subtype="Normal",
    depends_on={"installed_capacity_res_elec": 1, 
                "cp_res_elec": 1, 
                "peak_load":1},
)
def share_pv():
    """
    The share PV represents the ratio of electricity generated by solar panels over the peak load.
    """

    share_pv = float(installed_capacity_res_elec().loc['solar_PV']*cp_res_elec().loc['solar_PV'])/peak_load()/0.736
    bounds = (0, 0.35)
    if share_pv < bounds[0]:
        print(f"\nLower bound for share_pv reached. ({share_pv})")
        return bounds[0]
    elif share_pv > bounds[1]:
        print(f"\nUpper bound for share_pv reached. ({share_pv})")
        return bounds[1]
    else:
        return share_pv

@component.add(
    name="Net Transfer Capacity Ratio",
    units="Dmnl",
    comp_type="Data",
    comp_subtype="External",
    depends_on={"time": 1, 
                "cumulated_add_rNTC_feedback": 1},
)
def rNTC():
    """
    The Net Transfer Capacity Ratio is an artificial ratio that depicts the global interconnection state of an electrical network.
    It increases along the network ability to share electrcity between distant areas. 
    Data is taken from PyPSA-EUR model, please refers to Section 3.6 of No√© Diffels' master thesis for further information. 
    """    
    pypsa_rNTC = df_rNTC.loc[round(time()), "rNTC"] # Round otherwise error induced by curtailment_delayed(), ts = 1995.0325 for exple.
    rNTC = pypsa_rNTC # rNTC evolution "base load", without taking into account the feedback loop.

    add_rNTC = float(cumulated_add_rNTC_feedback())
    
    rNTC += add_rNTC

    bounds = (0, 0.75)
    if rNTC < bounds[0]:
        print(f"\nLower bound for rNTC reached. ({rNTC})")
        return bounds[0]
    elif rNTC > bounds[1]:
        print(f"\nUpper bound for rNTC reached. ({rNTC})")
        return bounds[1]
    else:
        return rNTC


@component.add(
    name="Added Net Transfer Capacity Ratio by feedback mechanism",
    units="Dmnl",
    comp_type="Data",
    comp_subtype="External",
    depends_on={"time": 1,
                "sm_new_capacity_ntc": 1},
)
def add_rNTC_feedback():
    ratio_rNTC_TW = df_ratios_rNTC_TW['Ratio'].loc[round(time())]
    return float(sm_new_capacity_ntc()) * ratio_rNTC_TW

@component.add(
    name="cumulated_add_rNTC_feedback",
    units="Dmnl",
    comp_type="Stateful",
    comp_subtype="Integ",
    depends_on={"_integ_cumulated_add_rNTC_feedback": 1},
    other_deps={
        "_integ_cumulated_add_rNTC_feedback": {
            "initial": {},
            "step": {"add_rNTC_feedback": 1},
        }
    },
)
def cumulated_add_rNTC_feedback():
    """
    Cumulated additional rNTC from the feedback mechanism
    """
    return _integ_cumulated_add_rNTC_feedback()
_integ_cumulated_add_rNTC_feedback = Integ(
    lambda: float(add_rNTC_feedback()),
    lambda: 0,
    "_integ_cumulated_add_rNTC_feedback",
)